package qupath.ext.quiet.export;

import static qupath.ext.quiet.export.ScriptGenerator.appendLine;
import static qupath.ext.quiet.export.ScriptGenerator.quote;

/**
 * Generates self-contained Groovy scripts for per-object crop export.
 * <p>
 * The generated script iterates over detection/cell objects, reads a crop
 * centered on each object's centroid, and writes it to the output directory
 * organized by classification label.
 */
class ObjectCropScriptGenerator {

    private ObjectCropScriptGenerator() {
        // Utility class
    }

    static String generate(ObjectCropConfig config) {
        var sb = new StringBuilder();

        appendLine(sb, "/**");
        appendLine(sb, " * Object Crop Export Script (Classification Training)");
        appendLine(sb, " * Generated by QuIET (QuPath Image Export Toolkit)");
        appendLine(sb, " *");
        appendLine(sb, " * Exports image patches centered on detections/cells,");
        appendLine(sb, " * organized by classification for ML training.");
        appendLine(sb, " * Crop size: " + config.getCropSize() + "x" + config.getCropSize());
        appendLine(sb, " *");
        appendLine(sb, " * Parameters below can be modified before re-running.");
        appendLine(sb, " */");
        appendLine(sb, "");

        // Imports
        appendLine(sb, "import javax.imageio.ImageIO");
        appendLine(sb, "import qupath.lib.regions.RegionRequest");
        appendLine(sb, "");

        // Configuration parameters
        appendLine(sb, "// ========== CONFIGURATION (modify as needed) ==========");
        appendLine(sb, "def objectType = " + quote(config.getObjectType().name()));
        appendLine(sb, "def cropSize = " + config.getCropSize());
        appendLine(sb, "def padding = " + config.getPadding());
        appendLine(sb, "def downsample = " + config.getDownsample());
        appendLine(sb, "def labelFormat = " + quote(config.getLabelFormat().name()));
        appendLine(sb, "def imageFormat = " + quote(config.getFormat().getExtension()));
        appendLine(sb, "def outputDir = " + quote(config.getOutputDirectory().getAbsolutePath()));

        // Selected classes
        var classes = config.getSelectedClasses();
        if (!classes.isEmpty()) {
            var classStr = new StringBuilder("def selectedClasses = [");
            for (int i = 0; i < classes.size(); i++) {
                if (i > 0) classStr.append(", ");
                classStr.append(quote(classes.get(i)));
            }
            classStr.append("]");
            appendLine(sb, classStr.toString());
        } else {
            appendLine(sb, "def selectedClasses = [] // empty = all classes");
        }

        appendLine(sb, "// =======================================================");
        appendLine(sb, "");

        // Script body
        appendLine(sb, "def imageData = getCurrentImageData()");
        appendLine(sb, "if (imageData == null) {");
        appendLine(sb, "    println 'ERROR: No image is open'");
        appendLine(sb, "    return");
        appendLine(sb, "}");
        appendLine(sb, "");

        appendLine(sb, "def server = imageData.getServer()");
        appendLine(sb, "def hierarchy = imageData.getHierarchy()");
        appendLine(sb, "int serverW = server.getWidth()");
        appendLine(sb, "int serverH = server.getHeight()");
        appendLine(sb, "");

        // Get objects
        appendLine(sb, "// Get objects based on type");
        appendLine(sb, "def objects");
        appendLine(sb, "switch (objectType) {");
        appendLine(sb, "    case 'DETECTIONS': objects = getDetectionObjects(); break");
        appendLine(sb, "    case 'CELLS': objects = getCellObjects(); break");
        appendLine(sb, "    case 'ALL': objects = getDetectionObjects() + getCellObjects().findAll { !(it instanceof qupath.lib.objects.PathDetectionObject) }; break");
        appendLine(sb, "    default: objects = getDetectionObjects()");
        appendLine(sb, "}");
        appendLine(sb, "");

        // Filter by class
        appendLine(sb, "if (!selectedClasses.isEmpty()) {");
        appendLine(sb, "    objects = objects.findAll { it.getPathClass() != null && selectedClasses.contains(it.getPathClass().getName()) }");
        appendLine(sb, "}");
        appendLine(sb, "");
        appendLine(sb, "println \"Found ${objects.size()} objects to export\"");
        appendLine(sb, "");

        // Output directory
        appendLine(sb, "def outDir = new File(outputDir)");
        appendLine(sb, "outDir.mkdirs()");
        appendLine(sb, "");

        // Main loop
        appendLine(sb, "int halfCrop = (int) Math.round((cropSize / 2.0) * downsample)");
        appendLine(sb, "int paddingScaled = (int) Math.round(padding * downsample)");
        appendLine(sb, "def classCounters = [:]");
        appendLine(sb, "int exported = 0");
        appendLine(sb, "");

        appendLine(sb, "for (obj in objects) {");
        appendLine(sb, "    def roi = obj.getROI()");
        appendLine(sb, "    if (roi == null) continue");
        appendLine(sb, "");
        appendLine(sb, "    int regionSize = (halfCrop + paddingScaled) * 2");
        appendLine(sb, "    int x = (int) Math.round(roi.getCentroidX()) - halfCrop - paddingScaled");
        appendLine(sb, "    int y = (int) Math.round(roi.getCentroidY()) - halfCrop - paddingScaled");
        appendLine(sb, "    x = Math.max(0, x)");
        appendLine(sb, "    y = Math.max(0, y)");
        appendLine(sb, "    int w = Math.min(regionSize, serverW - x)");
        appendLine(sb, "    int h = Math.min(regionSize, serverH - y)");
        appendLine(sb, "    if (w <= 0 || h <= 0) continue");
        appendLine(sb, "");
        appendLine(sb, "    def region = RegionRequest.createInstance(server.getPath(), downsample, x, y, w, h)");
        appendLine(sb, "    def crop = server.readRegion(region)");
        appendLine(sb, "");
        appendLine(sb, "    String className = (obj.getPathClass() != null) ? obj.getPathClass().getName() : 'Unclassified'");
        appendLine(sb, "    String safeClass = className.replaceAll('[^a-zA-Z0-9._\\\\-]', '_')");
        appendLine(sb, "    int idx = (classCounters[className] ?: 0) + 1");
        appendLine(sb, "    classCounters[className] = idx");
        appendLine(sb, "");
        appendLine(sb, "    def entryName = getCurrentImageData().getServer().getMetadata().getName()");
        appendLine(sb, "    String safeEntry = entryName.replaceAll('[^a-zA-Z0-9._\\\\-]', '_')");
        appendLine(sb, "");
        appendLine(sb, "    File outputFile");
        appendLine(sb, "    if (labelFormat == 'SUBDIRECTORY') {");
        appendLine(sb, "        outputFile = new File(new File(outDir, safeClass), safeEntry + '_' + idx + '.' + imageFormat)");
        appendLine(sb, "    } else {");
        appendLine(sb, "        outputFile = new File(outDir, safeClass + '_' + safeEntry + '_' + idx + '.' + imageFormat)");
        appendLine(sb, "    }");
        appendLine(sb, "    outputFile.getParentFile().mkdirs()");
        appendLine(sb, "");
        appendLine(sb, "    String fmt = imageFormat == 'tif' ? 'tiff' : imageFormat");
        appendLine(sb, "    ImageIO.write(crop, fmt, outputFile)");
        appendLine(sb, "    exported++");
        appendLine(sb, "}");
        appendLine(sb, "");
        appendLine(sb, "println \"Exported ${exported} object crops\"");

        return sb.toString();
    }
}
