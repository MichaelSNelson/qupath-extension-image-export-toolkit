package qupath.ext.quiet.scripting;

import qupath.ext.quiet.export.MaskExportConfig;
import qupath.ext.quiet.export.TiledExportConfig;

import static qupath.ext.quiet.scripting.ScriptGenerator.appendLine;
import static qupath.ext.quiet.scripting.ScriptGenerator.quote;

/**
 * Generates self-contained Groovy scripts for tiled ML training export
 * using QuPath's TileExporter API.
 */
class TiledScriptGenerator {

    private TiledScriptGenerator() {
        // Utility class
    }

    static String generate(TiledExportConfig config) {
        var sb = new StringBuilder();

        appendLine(sb, "/**");
        appendLine(sb, " * Tiled Image Export Script (ML Training)");
        appendLine(sb, " * Generated by QuIET (QuPath Image Export Toolkit)");
        appendLine(sb, " *");
        appendLine(sb, " * Exports image+label tile pairs using TileExporter.");
        appendLine(sb, " * Tile size: " + config.getTileSize() + "x" + config.getTileSize());
        appendLine(sb, " * Overlap: " + config.getOverlap() + " px");
        appendLine(sb, " *");
        appendLine(sb, " * Parameters below can be modified before re-running.");
        appendLine(sb, " */");
        appendLine(sb, "");

        // Imports
        appendLine(sb, "import qupath.lib.images.writers.TileExporter");
        if (config.getLabelFormat() != null) {
            appendLine(sb, "import qupath.lib.images.servers.LabeledImageServer");
            appendLine(sb, "import qupath.lib.objects.classes.PathClass");
        }
        appendLine(sb, "");

        // Configuration parameters
        appendLine(sb, "// ========== CONFIGURATION (modify as needed) ==========");
        appendLine(sb, "def tileSize = " + config.getTileSize());
        appendLine(sb, "def overlap = " + config.getOverlap());
        appendLine(sb, "def downsample = " + config.getDownsample());
        appendLine(sb, "def imageFormat = " + quote("." + config.getImageFormat().getExtension()));
        if (config.getLabelFormat() != null) {
            appendLine(sb, "def labelFormat = " + quote("." + config.getLabelFormat().getExtension()));
        }
        appendLine(sb, "def outputDir = " + quote(config.getOutputDirectory().getAbsolutePath()));
        appendLine(sb, "def annotatedOnly = " + config.isAnnotatedTilesOnly());
        appendLine(sb, "def exportJson = " + config.isExportGeoJson());
        appendLine(sb, "def parentFilter = " + quote(config.getParentObjectFilter().name()));

        // Label configuration
        MaskExportConfig labelConfig = config.getLabeledServerConfig();
        if (config.getLabelFormat() != null && labelConfig != null) {
            appendLine(sb, "def labelMaskType = " + quote(labelConfig.getMaskType().name()));
            appendLine(sb, "def labelObjectSource = " + quote(labelConfig.getObjectSource().name()));
            appendLine(sb, "def labelBackgroundLabel = " + labelConfig.getBackgroundLabel());
            var classes = labelConfig.getSelectedClassifications();
            if (!classes.isEmpty()) {
                var classStr = new StringBuilder("def labelClassifications = [");
                for (int i = 0; i < classes.size(); i++) {
                    if (i > 0) classStr.append(", ");
                    classStr.append(quote(classes.get(i)));
                }
                classStr.append("]");
                appendLine(sb, classStr.toString());
            } else {
                appendLine(sb, "def labelClassifications = []");
            }
        }

        appendLine(sb, "// =======================================================");
        appendLine(sb, "");

        // Project loading
        appendLine(sb, "def project = getProject()");
        appendLine(sb, "if (project == null) {");
        appendLine(sb, "    println 'ERROR: No project is open'");
        appendLine(sb, "    return");
        appendLine(sb, "}");
        appendLine(sb, "");

        // Output directory
        appendLine(sb, "def outDir = new File(outputDir)");
        appendLine(sb, "outDir.mkdirs()");
        appendLine(sb, "");

        // Main processing loop
        appendLine(sb, "def entries = project.getImageList()");
        appendLine(sb, "println \"Processing ${entries.size()} images...\"");
        appendLine(sb, "");
        appendLine(sb, "int succeeded = 0");
        appendLine(sb, "int failed = 0");
        appendLine(sb, "");
        appendLine(sb, "for (int i = 0; i < entries.size(); i++) {");
        appendLine(sb, "    def entry = entries[i]");
        appendLine(sb, "    def entryName = entry.getImageName()");
        appendLine(sb, "    println \"[${i + 1}/${entries.size()}] Processing: ${entryName}\"");
        appendLine(sb, "");
        appendLine(sb, "    def labelServer = null");
        appendLine(sb, "    try {");
        appendLine(sb, "        def imageData = entry.readImageData()");
        appendLine(sb, "");

        // Build label server if needed
        if (config.getLabelFormat() != null) {
            appendLine(sb, "        // Build label server for mask tiles");
            appendLine(sb, "        def builder = new LabeledImageServer.Builder(imageData)");
            appendLine(sb, "                .backgroundLabel(labelBackgroundLabel)");
            appendLine(sb, "                .downsample(downsample)");
            appendLine(sb, "");

            if (labelConfig != null) {
                // Object source
                appendLine(sb, "        switch (labelObjectSource) {");
                appendLine(sb, "            case 'ANNOTATIONS': builder.useAnnotations(); break");
                appendLine(sb, "            case 'DETECTIONS': builder.useDetections(); break");
                appendLine(sb, "            case 'CELLS': builder.useCells(); break");
                appendLine(sb, "        }");
                appendLine(sb, "");

                // Mask type
                appendLine(sb, "        switch (labelMaskType) {");
                appendLine(sb, "            case 'BINARY':");
                appendLine(sb, "                if (labelClassifications.isEmpty()) {");
                appendLine(sb, "                    builder.addUnclassifiedLabel(1)");
                appendLine(sb, "                } else {");
                appendLine(sb, "                    labelClassifications.each { builder.addLabel(PathClass.fromString(it), 1) }");
                appendLine(sb, "                }");
                appendLine(sb, "                break");
                appendLine(sb, "            case 'GRAYSCALE_LABELS':");
                appendLine(sb, "                builder.grayscale(true)");
                appendLine(sb, "                labelClassifications.eachWithIndex { cls, idx -> builder.addLabel(PathClass.fromString(cls), idx + 1) }");
                appendLine(sb, "                break");
                appendLine(sb, "            case 'INSTANCE':");
                appendLine(sb, "                builder.useInstanceLabels()");
                appendLine(sb, "                break");
                appendLine(sb, "            case 'COLORED':");
                appendLine(sb, "                labelClassifications.eachWithIndex { cls, idx -> builder.addLabel(PathClass.fromString(cls), idx + 1) }");
                appendLine(sb, "                break");
                appendLine(sb, "            case 'MULTICHANNEL':");
                appendLine(sb, "                builder.multichannelOutput(true)");
                appendLine(sb, "                labelClassifications.eachWithIndex { cls, idx -> builder.addLabel(PathClass.fromString(cls), idx + 1) }");
                appendLine(sb, "                break");
                appendLine(sb, "        }");
            } else {
                appendLine(sb, "        builder.useAnnotations()");
                appendLine(sb, "        builder.addUnclassifiedLabel(1)");
            }

            appendLine(sb, "");
            appendLine(sb, "        labelServer = builder.build()");
            appendLine(sb, "");
        }

        // Build TileExporter
        appendLine(sb, "        def exporter = new TileExporter(imageData)");
        appendLine(sb, "                .tileSize(tileSize)");
        appendLine(sb, "                .overlap(overlap)");
        appendLine(sb, "                .downsample(downsample)");
        appendLine(sb, "                .imageExtension(imageFormat)");
        appendLine(sb, "                .annotatedTilesOnly(annotatedOnly)");

        if (config.getLabelFormat() != null) {
            appendLine(sb, "                .labeledServer(labelServer)");
            appendLine(sb, "                .labeledImageExtension(labelFormat)");
        }
        if (config.isExportGeoJson()) {
            appendLine(sb, "                .exportJson(exportJson)");
        }
        appendLine(sb, "");

        // Parent object filter
        appendLine(sb, "        switch (parentFilter) {");
        appendLine(sb, "            case 'ANNOTATIONS':");
        appendLine(sb, "                exporter.parentObjects(imageData.getHierarchy().getAnnotationObjects())");
        appendLine(sb, "                break");
        appendLine(sb, "            case 'TMA_CORES':");
        appendLine(sb, "                if (imageData.getHierarchy().getTMAGrid() != null)");
        appendLine(sb, "                    exporter.parentObjects(imageData.getHierarchy().getTMAGrid().getTMACoreList())");
        appendLine(sb, "                break");
        appendLine(sb, "            case 'ALL': break // no filter");
        appendLine(sb, "        }");
        appendLine(sb, "");

        // Write tiles
        appendLine(sb, "        def sanitized = entryName.replaceAll('[^a-zA-Z0-9._\\\\-]', '_')");
        appendLine(sb, "        def imageOutDir = new File(outDir, sanitized)");
        appendLine(sb, "        imageOutDir.mkdirs()");
        appendLine(sb, "        exporter.writeTiles(imageOutDir.getAbsolutePath())");
        appendLine(sb, "        println \"  OK: ${imageOutDir.getAbsolutePath()}\"");
        appendLine(sb, "        succeeded++");
        appendLine(sb, "");
        if (config.getLabelFormat() != null) {
            appendLine(sb, "        if (labelServer != null) labelServer.close()");
            appendLine(sb, "        labelServer = null");
        }
        appendLine(sb, "        imageData.getServer().close()");
        appendLine(sb, "");
        appendLine(sb, "    } catch (Exception e) {");
        appendLine(sb, "        println \"  FAIL: ${e.getMessage()}\"");
        appendLine(sb, "        failed++");
        if (config.getLabelFormat() != null) {
            appendLine(sb, "        if (labelServer != null) {");
            appendLine(sb, "            try { labelServer.close() } catch (Exception ignored) {}");
            appendLine(sb, "        }");
        }
        appendLine(sb, "    }");
        appendLine(sb, "}");
        appendLine(sb, "");
        appendLine(sb, "println ''");
        appendLine(sb, "println \"Export complete: ${succeeded} succeeded, ${failed} failed\"");

        return sb.toString();
    }
}
