package qupath.ext.quiet.scripting;

import qupath.ext.quiet.export.MaskExportConfig;

import static qupath.ext.quiet.scripting.ScriptGenerator.appendLine;
import static qupath.ext.quiet.scripting.ScriptGenerator.quote;

/**
 * Generates self-contained Groovy scripts for mask/label export.
 */
class MaskScriptGenerator {

    private MaskScriptGenerator() {
        // Utility class
    }

    static String generate(MaskExportConfig config) {
        var sb = new StringBuilder();

        appendLine(sb, "/**");
        appendLine(sb, " * Mask/Label Export Script");
        appendLine(sb, " * Generated by QuIET (QuPath Image Export Toolkit)");
        appendLine(sb, " *");
        appendLine(sb, " * Exports label masks from project images using LabeledImageServer.");
        appendLine(sb, " * Mask type: " + config.getMaskType().name());
        appendLine(sb, " *");
        appendLine(sb, " * Parameters below can be modified before re-running.");
        appendLine(sb, " */");
        appendLine(sb, "");

        // Imports
        appendLine(sb, "import qupath.lib.images.servers.LabeledImageServer");
        appendLine(sb, "import qupath.lib.images.writers.ImageWriterTools");
        appendLine(sb, "import qupath.lib.objects.classes.PathClass");
        appendLine(sb, "import qupath.lib.regions.RegionRequest");
        appendLine(sb, "");

        // Configuration parameters
        appendLine(sb, "// ========== CONFIGURATION (modify as needed) ==========");
        appendLine(sb, "def maskType = " + quote(config.getMaskType().name()));
        appendLine(sb, "def downsample = " + config.getDownsample());
        appendLine(sb, "def outputFormat = " + quote(config.getFormat().getExtension()));
        appendLine(sb, "def outputDir = " + quote(config.getOutputDirectory().getAbsolutePath()));
        appendLine(sb, "def backgroundLabel = " + config.getBackgroundLabel());
        appendLine(sb, "def objectSource = " + quote(config.getObjectSource().name()));

        // Classification list
        var classes = config.getSelectedClassifications();
        if (!classes.isEmpty()) {
            var classStr = new StringBuilder("def classifications = [");
            for (int i = 0; i < classes.size(); i++) {
                if (i > 0) classStr.append(", ");
                classStr.append(quote(classes.get(i)));
            }
            classStr.append("]");
            appendLine(sb, classStr.toString());
        } else {
            appendLine(sb, "def classifications = []");
        }

        if (config.isEnableBoundary()) {
            appendLine(sb, "def boundaryLabel = " + config.getBoundaryLabel());
            if (config.getBoundaryThickness() > 1.0) {
                appendLine(sb, "def boundaryThickness = " + config.getBoundaryThickness());
            }
        }
        if (config.getMaskType() == MaskExportConfig.MaskType.INSTANCE && config.isShuffleInstanceLabels()) {
            appendLine(sb, "def shuffleLabels = true");
        }
        appendLine(sb, "// =======================================================");
        appendLine(sb, "");

        // Project loading
        appendLine(sb, "def project = getProject()");
        appendLine(sb, "if (project == null) {");
        appendLine(sb, "    println 'ERROR: No project is open'");
        appendLine(sb, "    return");
        appendLine(sb, "}");
        appendLine(sb, "");

        // Output directory
        appendLine(sb, "def outDir = new File(outputDir)");
        appendLine(sb, "outDir.mkdirs()");
        appendLine(sb, "");

        // Main processing loop
        appendLine(sb, "def entries = project.getImageList()");
        appendLine(sb, "println \"Processing ${entries.size()} images...\"");
        appendLine(sb, "");
        appendLine(sb, "int succeeded = 0");
        appendLine(sb, "int failed = 0");
        appendLine(sb, "");
        appendLine(sb, "for (int i = 0; i < entries.size(); i++) {");
        appendLine(sb, "    def entry = entries[i]");
        appendLine(sb, "    def entryName = entry.getImageName()");
        appendLine(sb, "    println \"[${i + 1}/${entries.size()}] Processing: ${entryName}\"");
        appendLine(sb, "");
        appendLine(sb, "    def labelServer = null");
        appendLine(sb, "    try {");
        appendLine(sb, "        def imageData = entry.readImageData()");
        appendLine(sb, "        def builder = new LabeledImageServer.Builder(imageData)");
        appendLine(sb, "");
        appendLine(sb, "        builder.backgroundLabel(backgroundLabel)");
        appendLine(sb, "        builder.downsample(downsample)");
        appendLine(sb, "");

        // Object source
        appendLine(sb, "        switch (objectSource) {");
        appendLine(sb, "            case 'ANNOTATIONS': builder.useAnnotations(); break");
        appendLine(sb, "            case 'DETECTIONS': builder.useDetections(); break");
        appendLine(sb, "            case 'CELLS': builder.useCells(); break");
        appendLine(sb, "        }");
        appendLine(sb, "");

        // Boundary label
        if (config.isEnableBoundary()) {
            if (config.getBoundaryThickness() > 1.0) {
                appendLine(sb, "        builder.setBoundaryLabel('Boundary', boundaryLabel, boundaryThickness)");
            } else {
                appendLine(sb, "        builder.setBoundaryLabel('Boundary', boundaryLabel)");
            }
            appendLine(sb, "");
        }

        // Mask type configuration
        appendLine(sb, "        switch (maskType) {");
        appendLine(sb, "            case 'BINARY':");
        appendLine(sb, "                if (classifications.isEmpty()) {");
        appendLine(sb, "                    builder.addUnclassifiedLabel(1)");
        appendLine(sb, "                } else {");
        appendLine(sb, "                    classifications.each { builder.addLabel(PathClass.fromString(it), 1) }");
        appendLine(sb, "                }");
        appendLine(sb, "                break");
        appendLine(sb, "            case 'GRAYSCALE_LABELS':");
        appendLine(sb, "                builder.grayscale(true)");
        appendLine(sb, "                classifications.eachWithIndex { cls, idx -> builder.addLabel(PathClass.fromString(cls), idx + 1) }");
        appendLine(sb, "                break");
        appendLine(sb, "            case 'COLORED':");
        appendLine(sb, "                classifications.eachWithIndex { cls, idx -> builder.addLabel(PathClass.fromString(cls), idx + 1) }");
        appendLine(sb, "                break");
        appendLine(sb, "            case 'INSTANCE':");
        appendLine(sb, "                builder.useInstanceLabels()");
        if (config.isShuffleInstanceLabels()) {
            appendLine(sb, "                if (shuffleLabels) builder.shuffleInstanceLabels(true)");
        }
        appendLine(sb, "                break");
        appendLine(sb, "            case 'MULTICHANNEL':");
        appendLine(sb, "                builder.multichannelOutput(true)");
        appendLine(sb, "                classifications.eachWithIndex { cls, idx -> builder.addLabel(PathClass.fromString(cls), idx + 1) }");
        appendLine(sb, "                break");
        appendLine(sb, "        }");
        appendLine(sb, "");
        appendLine(sb, "        labelServer = builder.build()");
        appendLine(sb, "");
        appendLine(sb, "        def request = RegionRequest.createInstance(");
        appendLine(sb, "                labelServer.getPath(), downsample,");
        appendLine(sb, "                0, 0, labelServer.getWidth(), labelServer.getHeight())");
        appendLine(sb, "        def maskImage = labelServer.readRegion(request)");
        appendLine(sb, "");
        appendLine(sb, "        def sanitized = entryName.replaceAll('[^a-zA-Z0-9._\\\\-]', '_')");
        appendLine(sb, "        def outputPath = new File(outDir, sanitized + '.' + outputFormat).getAbsolutePath()");
        appendLine(sb, "        ImageWriterTools.writeImage(maskImage, outputPath)");
        appendLine(sb, "        println \"  OK: ${outputPath}\"");
        appendLine(sb, "        succeeded++");
        appendLine(sb, "");
        appendLine(sb, "        labelServer.close()");
        appendLine(sb, "        labelServer = null");
        appendLine(sb, "        imageData.getServer().close()");
        appendLine(sb, "");
        appendLine(sb, "    } catch (Exception e) {");
        appendLine(sb, "        println \"  FAIL: ${e.getMessage()}\"");
        appendLine(sb, "        failed++");
        appendLine(sb, "        if (labelServer != null) {");
        appendLine(sb, "            try { labelServer.close() } catch (Exception ignored) {}");
        appendLine(sb, "        }");
        appendLine(sb, "    }");
        appendLine(sb, "}");
        appendLine(sb, "");
        appendLine(sb, "println ''");
        appendLine(sb, "println \"Export complete: ${succeeded} succeeded, ${failed} failed\"");

        return sb.toString();
    }
}
